namespace Challenges.Tests;

using static BitsAndBytes;

public class BitsAndBytesTests
{
    [Theory]
    [InlineData(0x00, 0)]
    [InlineData(0x01, 1)]
    [InlineData(0x0c, 2)]
    [InlineData(0x04bc, 6)]
    [InlineData(0x01d97c, 11)]
    [InlineData(0xFFFFFFFF, 32)]
    public void BitCount_ReturnsTheCorrectNumberOfBits(uint input, int expected)
    {
        var result = BitCount(input);
        
        Assert.Equal(expected, result);
    }
    
    [Theory]
    [InlineData(new byte[] { 0x01, 0x02, 0x03, 0x04 }, 0, new byte[] { 0x00, 0x00, 0x00, 0x00 })]
    [InlineData(new byte[] { 0x01, 0x02, 0x03, 0x04 }, 1, new byte[] { 0x01, 0x00, 0x00, 0x00 })]
    [InlineData(new byte[] { 0x01, 0x02, 0x03, 0x04 }, 2, new byte[] { 0x01, 0x02, 0x00, 0x00 })]
    [InlineData(new byte[] { 0x01, 0x02, 0x03, 0x04 }, 3, new byte[] { 0x01, 0x02, 0x03, 0x00 })]
    [InlineData(new byte[] { 0x01, 0x02, 0x03, 0x04 }, 4, new byte[] { 0x01, 0x02, 0x03, 0x04 })]
    [InlineData(new byte[] { 0x01, 0x02, 0x03, 0x04 }, 5, new byte[] { 0x01, 0x02, 0x03, 0x04 })]
    public void ByteCopy_CopiesBytesCorrectly(byte[] src, int size, byte[] expected)
    {
        var dst = new byte[src.Length];
        
        ByteCopy(src, dst, size);
        
        Assert.Equal(expected, dst);
    }
    
    [Theory]
    [InlineData(new byte[] { 0x01, 0x02, 0x03, 0x04 }, 0, new byte[] { 0x01, 0x02, 0x03, 0x04 })]
    [InlineData(new byte[] { 0x01, 0x02, 0x03, 0x04 }, 1, new byte[] { 0x00, 0x02, 0x03, 0x04 })]
    [InlineData(new byte[] { 0x01, 0x02, 0x03, 0x04 }, 2, new byte[] { 0x00, 0x00, 0x03, 0x04 })]
    [InlineData(new byte[] { 0x01, 0x02, 0x03, 0x04 }, 3, new byte[] { 0x00, 0x00, 0x00, 0x04 })]
    [InlineData(new byte[] { 0x01, 0x02, 0x03, 0x04 }, 4, new byte[] { 0x00, 0x00, 0x00, 0x00 })]
    [InlineData(new byte[] { 0x01, 0x02, 0x03, 0x04 }, 5, new byte[] { 0x00, 0x00, 0x00, 0x00 })]
    public void ByteZero_SetCorrectAmountOfBytesToZero(byte[] a, int size, byte[] expected)
    {
        ByteZero(a, size);
        
        Assert.Equal(expected, a);
    }
    
    [Theory]
    [InlineData(new byte[] { 0x01, 0x02, 0x03, 0x04 }, 0, new byte[] { 0x01, 0x02, 0x03, 0x04 })]
    [InlineData(new byte[] { 0x01, 0x02, 0x03, 0x04 }, 1, new byte[] { 0xaa, 0x02, 0x03, 0x04 })]
    [InlineData(new byte[] { 0x01, 0x02, 0x03, 0x04 }, 2, new byte[] { 0xaa, 0xaa, 0x03, 0x04 })]
    [InlineData(new byte[] { 0x01, 0x02, 0x03, 0x04 }, 3, new byte[] { 0xaa, 0xaa, 0xaa, 0x04 })]
    [InlineData(new byte[] { 0x01, 0x02, 0x03, 0x04 }, 4, new byte[] { 0xaa, 0xaa, 0xaa, 0xaa })]
    [InlineData(new byte[] { 0x01, 0x02, 0x03, 0x04 }, 5, new byte[] { 0xaa, 0xaa, 0xaa, 0xaa })]
    public void ByteSet_SetsCorrectAbountOfBytesToValue(byte[] a, int size, byte[] expected)
    {
        const byte value = 0xaa;
        
        ByteSet(a, value, size);
        
        Assert.Equal(expected, a);
    }
}